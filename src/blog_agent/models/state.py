"""
Blog State Schema
=================

This module defines the STATE - the shared memory that flows through our agent workflow.

WHY THIS EXISTS:
---------------
In LangGraph, agents don't talk directly to each other. Instead, they all
read from and write to a shared "state" object. Think of it like a shared
document that everyone can edit:

1. Title Agent reads the topic, writes brainstormed titles
2. Content Agent reads the selected title, writes the blog content
3. Translation Agent reads the blog content, writes translated version

This is called "state management" and it's how complex workflows stay organized.

HOW IT WORKS:
-------------
We use Python's TypedDict to define exactly what fields our state has.
This gives us:
- Type checking (catch bugs before running)
- Autocomplete in IDEs
- Documentation of what data flows through the system

IMPORTANT CONCEPT - Reducers:
-----------------------------
When multiple agents write to the same field, LangGraph needs to know HOW to combine them.
This is what "reducers" do. For example:
- For a list: append new items (reducer = operator.add)
- For a single value: just replace it (default behavior)
"""

from typing import Annotated, TypedDict, Optional, List
import operator


class BlogState(TypedDict):
    """
    The complete state that flows through our blog generation pipeline.
    
    Think of this as a form that gets filled out step by step:
    
    INPUT FIELDS (provided by user):
    ├── topic: What to write about
    ├── transcript: Optional source material
    └── target_language: Optional translation language
    
    PROCESSING FIELDS (filled by agents):
    ├── brainstormed_titles: List of title options
    ├── selected_title: The chosen title
    └── blog_content: The written article
    
    OUTPUT FIELDS (final results):
    ├── translated_content: Translation (if requested)
    └── final_content: The polished, final blog post
    
    METADATA FIELDS (tracking info):
    ├── word_count: Length of the content
    └── generation_time: How long it took
    """
    
    # ═══════════════════════════════════════════════════════════════════
    # INPUT FIELDS - What the user provides
    # ═══════════════════════════════════════════════════════════════════
    
    topic: str
    """
    The main topic to write about.
    Example: "Benefits of remote work" or "How to learn Python"
    """
    
    transcript: Optional[str]
    """
    Optional video/podcast transcript to base the blog on.
    If provided, the content agent will use this as source material.
    Example: Raw transcript from a YouTube video
    """
    
    target_language: Optional[str]
    """
    Language to translate the final content into.
    If None or empty, no translation is performed.
    Example: "Spanish", "French", "German", "Japanese"
    """
    
    style: str
    """
    Writing style for the blog.
    Options: "professional", "casual", "technical", "storytelling"
    Default: "professional"
    """
    
    # ═══════════════════════════════════════════════════════════════════
    # PROCESSING FIELDS - Filled by agents during workflow
    # ═══════════════════════════════════════════════════════════════════
    
    brainstormed_titles: Annotated[List[str], operator.add]
    """
    List of title options generated by the Title Agent.
    Uses operator.add as reducer to accumulate titles.
    Example: ["10 Ways Remote Work...", "The Ultimate Guide to...", ...]
    """
    
    selected_title: str
    """
    The final chosen title (best from brainstormed_titles).
    This will be used as the blog post's headline.
    """
    
    blog_content: str
    """
    The main blog content written by the Content Agent.
    This is the full article body, formatted in markdown.
    """
    
    # ═══════════════════════════════════════════════════════════════════
    # OUTPUT FIELDS - Final results
    # ═══════════════════════════════════════════════════════════════════
    
    translated_content: Optional[str]
    """
    The blog content translated to target_language.
    Only populated if translation was requested.
    """
    
    final_content: str
    """
    The polished, ready-to-publish content.
    Either translated_content or blog_content, depending on the path taken.
    """
    
    # ═══════════════════════════════════════════════════════════════════
    # METADATA FIELDS - Tracking and analytics
    # ═══════════════════════════════════════════════════════════════════
    
    word_count: int
    """
    Number of words in the final content.
    Useful for ensuring minimum length requirements.
    """
    
    generation_time: float
    """
    Total time in seconds to generate the content.
    Useful for performance monitoring.
    """


# Default values for initializing state
DEFAULT_STATE: BlogState = {
    "topic": "",
    "transcript": None,
    "target_language": None,
    "style": "professional",
    "brainstormed_titles": [],
    "selected_title": "",
    "blog_content": "",
    "translated_content": None,
    "final_content": "",
    "word_count": 0,
    "generation_time": 0.0,
}


# Export for easy importing
__all__ = ["BlogState", "DEFAULT_STATE"]
